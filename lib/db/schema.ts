import { sqliteTable, text, integer, index } from "drizzle-orm/sqlite-core";
import { sql, relations } from "drizzle-orm";

// =====================================================
// Better Auth Tables (generated by @better-auth/cli)
// =====================================================

export const user = sqliteTable("user", {
  id: text("id").primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  emailVerified: integer("email_verified", { mode: "boolean" })
    .default(false)
    .notNull(),
  image: text("image"),
  createdAt: integer("created_at", { mode: "timestamp_ms" })
    .default(sql`(cast(unixepoch('subsecond') * 1000 as integer))`)
    .notNull(),
  updatedAt: integer("updated_at", { mode: "timestamp_ms" })
    .default(sql`(cast(unixepoch('subsecond') * 1000 as integer))`)
    .$onUpdate(() => new Date())
    .notNull(),
  // Better Auth Admin Plugin fields
  role: text("role"),
  banned: integer("banned", { mode: "boolean" }).default(false),
  banReason: text("ban_reason"),
  banExpires: integer("ban_expires", { mode: "timestamp_ms" }),
});

export const session = sqliteTable(
  "session",
  {
    id: text("id").primaryKey(),
    expiresAt: integer("expires_at", { mode: "timestamp_ms" }).notNull(),
    token: text("token").notNull().unique(),
    createdAt: integer("created_at", { mode: "timestamp_ms" })
      .default(sql`(cast(unixepoch('subsecond') * 1000 as integer))`)
      .notNull(),
    updatedAt: integer("updated_at", { mode: "timestamp_ms" })
      .$onUpdate(() => new Date())
      .notNull(),
    ipAddress: text("ip_address"),
    userAgent: text("user_agent"),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    // Better Auth Admin Plugin field
    impersonatedBy: text("impersonated_by"),
  },
  (table) => [index("session_userId_idx").on(table.userId)]
);

export const account = sqliteTable(
  "account",
  {
    id: text("id").primaryKey(),
    accountId: text("account_id").notNull(),
    providerId: text("provider_id").notNull(),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    accessToken: text("access_token"),
    refreshToken: text("refresh_token"),
    idToken: text("id_token"),
    accessTokenExpiresAt: integer("access_token_expires_at", {
      mode: "timestamp_ms",
    }),
    refreshTokenExpiresAt: integer("refresh_token_expires_at", {
      mode: "timestamp_ms",
    }),
    scope: text("scope"),
    password: text("password"),
    createdAt: integer("created_at", { mode: "timestamp_ms" })
      .default(sql`(cast(unixepoch('subsecond') * 1000 as integer))`)
      .notNull(),
    updatedAt: integer("updated_at", { mode: "timestamp_ms" })
      .$onUpdate(() => new Date())
      .notNull(),
  },
  (table) => [index("account_userId_idx").on(table.userId)]
);

export const verification = sqliteTable("verification", {
  id: text("id").primaryKey(),
  identifier: text("identifier").notNull(),
  value: text("value").notNull(),
  expiresAt: integer("expires_at", { mode: "timestamp_ms" }).notNull(),
  createdAt: integer("created_at", { mode: "timestamp_ms" })
    .default(sql`(cast(unixepoch('subsecond') * 1000 as integer))`)
    .notNull(),
  updatedAt: integer("updated_at", { mode: "timestamp_ms" }).$onUpdate(
    () => new Date()
  ),
});

// =====================================================
// BetterShift Application Tables
// =====================================================

export const calendars = sqliteTable(
  "calendars",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    name: text("name").notNull(),
    color: text("color").notNull().default("#3b82f6"),
    ownerId: text("owner_id").references(() => user.id, {
      onDelete: "set null",
    }),
    guestPermission: text("guest_permission", {
      enum: ["none", "read", "write"],
    })
      .notNull()
      .default("none"),
    createdAt: integer("created_at", { mode: "timestamp" })
      .notNull()
      .default(sql`CURRENT_TIMESTAMP`),
    updatedAt: integer("updated_at", { mode: "timestamp" })
      .notNull()
      .default(sql`CURRENT_TIMESTAMP`),
  },
  (table) => [index("calendars_ownerId_idx").on(table.ownerId)]
);

export const calendarShares = sqliteTable(
  "calendar_shares",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    calendarId: text("calendar_id")
      .notNull()
      .references(() => calendars.id, { onDelete: "cascade" }),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    permission: text("permission", { enum: ["admin", "write", "read"] })
      .notNull()
      .default("read"),
    sharedBy: text("shared_by")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    createdAt: integer("created_at", { mode: "timestamp" })
      .notNull()
      .default(sql`CURRENT_TIMESTAMP`),
  },
  (table) => [
    index("calendar_shares_calendarId_idx").on(table.calendarId),
    index("calendar_shares_userId_idx").on(table.userId),
  ]
);

export const userCalendarSubscriptions = sqliteTable(
  "user_calendar_subscriptions",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    calendarId: text("calendar_id")
      .notNull()
      .references(() => calendars.id, { onDelete: "cascade" }),
    status: text("status", { enum: ["subscribed", "dismissed"] })
      .notNull()
      .default("subscribed"),
    source: text("source", { enum: ["guest", "shared"] })
      .notNull()
      .default("guest"),
    createdAt: integer("created_at", { mode: "timestamp" })
      .notNull()
      .default(sql`CURRENT_TIMESTAMP`),
    updatedAt: integer("updated_at", { mode: "timestamp" })
      .notNull()
      .default(sql`CURRENT_TIMESTAMP`)
      .$onUpdate(() => new Date()),
  },
  (table) => [
    index("user_calendar_subscriptions_userId_idx").on(table.userId),
    index("user_calendar_subscriptions_calendarId_idx").on(table.calendarId),
    index("user_calendar_subscriptions_status_idx").on(table.status),
  ]
);

export const externalSyncs = sqliteTable("external_syncs", {
  id: text("id")
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  calendarId: text("calendar_id")
    .notNull()
    .references(() => calendars.id, { onDelete: "cascade" }),
  name: text("name").notNull(),
  syncType: text("sync_type").notNull().default("icloud"), // icloud, google, custom
  calendarUrl: text("calendar_url").notNull(),
  color: text("color").notNull().default("#3b82f6"),
  displayMode: text("display_mode").notNull().default("normal"),
  isHidden: integer("is_hidden", { mode: "boolean" }).notNull().default(false),
  hideFromStats: integer("hide_from_stats", { mode: "boolean" })
    .notNull()
    .default(false),
  autoSyncInterval: integer("auto_sync_interval").notNull().default(0), // 0 = manual, otherwise minutes
  isOneTimeImport: integer("is_one_time_import", { mode: "boolean" })
    .notNull()
    .default(false), // true for uploaded files (no sync), false for URLs (can sync)
  lastSyncedAt: integer("last_synced_at", { mode: "timestamp" }),
  createdAt: integer("created_at", { mode: "timestamp" })
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
  updatedAt: integer("updated_at", { mode: "timestamp" })
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
});

export const shifts = sqliteTable("shifts", {
  id: text("id")
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  calendarId: text("calendar_id")
    .notNull()
    .references(() => calendars.id, { onDelete: "cascade" }),
  presetId: text("preset_id").references(() => shiftPresets.id, {
    onDelete: "set null",
  }),
  date: integer("date", { mode: "timestamp" }).notNull(),
  startTime: text("start_time").notNull(),
  endTime: text("end_time").notNull(),
  title: text("title").notNull(),
  color: text("color").notNull().default("#3b82f6"),
  notes: text("notes"),
  isAllDay: integer("is_all_day", { mode: "boolean" }).notNull().default(false),
  isSecondary: integer("is_secondary", { mode: "boolean" })
    .notNull()
    .default(false),
  externalEventId: text("external_event_id"),
  externalSyncId: text("external_sync_id").references(() => externalSyncs.id, {
    onDelete: "cascade",
  }),
  syncedFromExternal: integer("synced_from_external", { mode: "boolean" })
    .notNull()
    .default(false),
  createdAt: integer("created_at", { mode: "timestamp" })
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
  updatedAt: integer("updated_at", { mode: "timestamp" })
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
});

export const shiftPresets = sqliteTable("shift_presets", {
  id: text("id")
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  calendarId: text("calendar_id")
    .notNull()
    .references(() => calendars.id, { onDelete: "cascade" }),
  title: text("title").notNull(),
  startTime: text("start_time").notNull(),
  endTime: text("end_time").notNull(),
  color: text("color").notNull().default("#3b82f6"),
  notes: text("notes"),
  isSecondary: integer("is_secondary", { mode: "boolean" })
    .notNull()
    .default(false),
  isAllDay: integer("is_all_day", { mode: "boolean" }).notNull().default(false),
  hideFromStats: integer("hide_from_stats", { mode: "boolean" })
    .notNull()
    .default(false),
  order: integer("order").notNull().default(0),
  createdAt: integer("created_at", { mode: "timestamp" })
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
  updatedAt: integer("updated_at", { mode: "timestamp" })
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
});

export const calendarNotes = sqliteTable("calendar_notes", {
  id: text("id")
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  calendarId: text("calendar_id")
    .notNull()
    .references(() => calendars.id, { onDelete: "cascade" }),
  date: integer("date", { mode: "timestamp" }).notNull(),
  note: text("note").notNull(),
  type: text("type").notNull().default("note"), // note or event
  color: text("color"), // for events only
  recurringPattern: text("recurring_pattern").notNull().default("none"), // none, custom-weeks, custom-months
  recurringInterval: integer("recurring_interval"), // for custom pattern (e.g., every 3 months)
  createdAt: integer("created_at", { mode: "timestamp" })
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
  updatedAt: integer("updated_at", { mode: "timestamp" })
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
});

export const syncLogs = sqliteTable("sync_logs", {
  id: text("id")
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  calendarId: text("calendar_id")
    .notNull()
    .references(() => calendars.id, { onDelete: "cascade" }),
  externalSyncId: text("external_sync_id")
    .notNull()
    .references(() => externalSyncs.id, { onDelete: "cascade" }),
  externalSyncName: text("external_sync_name").notNull(), // Denormalized for history
  status: text("status").notNull(), // success, error
  errorMessage: text("error_message"),
  shiftsCreated: integer("shifts_created").notNull().default(0),
  shiftsUpdated: integer("shifts_updated").notNull().default(0),
  shiftsDeleted: integer("shifts_deleted").notNull().default(0),
  syncType: text("sync_type").notNull().default("auto"), // auto, manual
  isRead: integer("is_read", { mode: "boolean" }).notNull().default(false),
  syncedAt: integer("synced_at", { mode: "timestamp" })
    .notNull()
    .default(sql`CURRENT_TIMESTAMP`),
});

export const auditLogs = sqliteTable(
  "audit_logs",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    userId: text("user_id").references(() => user.id, {
      onDelete: "set null",
    }),
    action: text("action").notNull(),
    resourceType: text("resource_type"),
    resourceId: text("resource_id"),
    metadata: text("metadata"), // JSON string
    ipAddress: text("ip_address"),
    userAgent: text("user_agent"),
    severity: text("severity").notNull().default("info"), // info, warning, error, critical
    isUserVisible: integer("is_user_visible", { mode: "boolean" })
      .notNull()
      .default(false),
    timestamp: integer("timestamp", { mode: "timestamp" })
      .notNull()
      .default(sql`CURRENT_TIMESTAMP`),
  },
  (table) => [
    index("audit_logs_userId_timestamp_idx").on(table.userId, table.timestamp),
    index("audit_logs_action_timestamp_idx").on(table.action, table.timestamp),
    index("audit_logs_userVisible_userId_timestamp_idx").on(
      table.isUserVisible,
      table.userId,
      table.timestamp
    ),
  ]
);

export const calendarAccessTokens = sqliteTable(
  "calendar_access_tokens",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    calendarId: text("calendar_id")
      .notNull()
      .references(() => calendars.id, { onDelete: "cascade" }),
    token: text("token").notNull().unique(), // base64url encoded, 43 chars
    name: text("name"), // Optional label (e.g., "Family Link")
    permission: text("permission", { enum: ["read", "write"] })
      .notNull()
      .default("read"),
    expiresAt: integer("expires_at", { mode: "timestamp" }), // null = never expires
    createdBy: text("created_by")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    createdAt: integer("created_at", { mode: "timestamp" })
      .notNull()
      .default(sql`CURRENT_TIMESTAMP`),
    lastUsedAt: integer("last_used_at", { mode: "timestamp" }),
    usageCount: integer("usage_count").notNull().default(0),
    isActive: integer("is_active", { mode: "boolean" }).notNull().default(true),
  },
  (table) => [
    index("calendar_access_tokens_token_idx").on(table.token),
    index("calendar_access_tokens_calendarId_isActive_idx").on(
      table.calendarId,
      table.isActive
    ),
    index("calendar_access_tokens_createdBy_idx").on(table.createdBy),
  ]
);

export type Calendar = typeof calendars.$inferSelect;
export type NewCalendar = typeof calendars.$inferInsert;

export type CalendarAccessToken = typeof calendarAccessTokens.$inferSelect;
export type NewCalendarAccessToken = typeof calendarAccessTokens.$inferInsert;

export type ExternalSync = typeof externalSyncs.$inferSelect;
export type NewExternalSync = typeof externalSyncs.$inferInsert;

export type AuditLog = typeof auditLogs.$inferSelect;
export type NewAuditLog = typeof auditLogs.$inferInsert;
export type Shift = typeof shifts.$inferSelect;
export type NewShift = typeof shifts.$inferInsert;
export type ShiftPreset = typeof shiftPresets.$inferSelect;
export type NewShiftPreset = typeof shiftPresets.$inferInsert;
export type CalendarNote = typeof calendarNotes.$inferSelect;
export type NewCalendarNote = typeof calendarNotes.$inferInsert;
export type SyncLog = typeof syncLogs.$inferSelect;
export type NewSyncLog = typeof syncLogs.$inferInsert;

// Better Auth types
export type User = typeof user.$inferSelect;
export type NewUser = typeof user.$inferInsert;
export type Session = typeof session.$inferSelect;
export type Account = typeof account.$inferSelect;
export type CalendarShare = typeof calendarShares.$inferSelect;
export type NewCalendarShare = typeof calendarShares.$inferInsert;
export type UserCalendarSubscription =
  typeof userCalendarSubscriptions.$inferSelect;
export type NewUserCalendarSubscription =
  typeof userCalendarSubscriptions.$inferInsert;

// =====================================================
// Drizzle Relations (for experimental joins)
// =====================================================

export const userRelations = relations(user, ({ many }) => ({
  sessions: many(session),
  accounts: many(account),
  ownedCalendars: many(calendars),
  calendarShares: many(calendarShares),
  calendarSubscriptions: many(userCalendarSubscriptions),
  auditLogs: many(auditLogs),
}));

export const sessionRelations = relations(session, ({ one }) => ({
  user: one(user, {
    fields: [session.userId],
    references: [user.id],
  }),
}));

export const accountRelations = relations(account, ({ one }) => ({
  user: one(user, {
    fields: [account.userId],
    references: [user.id],
  }),
}));

export const calendarsRelations = relations(calendars, ({ one, many }) => ({
  owner: one(user, {
    fields: [calendars.ownerId],
    references: [user.id],
  }),
  shares: many(calendarShares),
  subscriptions: many(userCalendarSubscriptions),
  accessTokens: many(calendarAccessTokens),
  shifts: many(shifts),
  presets: many(shiftPresets),
  notes: many(calendarNotes),
  externalSyncs: many(externalSyncs),
  syncLogs: many(syncLogs),
}));

export const calendarSharesRelations = relations(calendarShares, ({ one }) => ({
  calendar: one(calendars, {
    fields: [calendarShares.calendarId],
    references: [calendars.id],
  }),
  user: one(user, {
    fields: [calendarShares.userId],
    references: [user.id],
  }),
  sharedByUser: one(user, {
    fields: [calendarShares.sharedBy],
    references: [user.id],
  }),
}));

export const userCalendarSubscriptionsRelations = relations(
  userCalendarSubscriptions,
  ({ one }) => ({
    user: one(user, {
      fields: [userCalendarSubscriptions.userId],
      references: [user.id],
    }),
    calendar: one(calendars, {
      fields: [userCalendarSubscriptions.calendarId],
      references: [calendars.id],
    }),
  })
);

export const auditLogsRelations = relations(auditLogs, ({ one }) => ({
  user: one(user, {
    fields: [auditLogs.userId],
    references: [user.id],
  }),
}));

export const calendarAccessTokensRelations = relations(
  calendarAccessTokens,
  ({ one }) => ({
    calendar: one(calendars, {
      fields: [calendarAccessTokens.calendarId],
      references: [calendars.id],
    }),
    createdByUser: one(user, {
      fields: [calendarAccessTokens.createdBy],
      references: [user.id],
    }),
  })
);
